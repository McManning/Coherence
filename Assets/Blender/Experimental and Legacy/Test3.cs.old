using SharedMemory;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using UnityEngine;

public class Test3 : MonoBehaviour
{
    public string BufferName = "Fizz Buzz";

    private RpcBuffer rpc;

    UnityState unityState;
    BlenderViewport blenderState;

    void OnEnable()
    {
        unityState.version = 14;
    }

    private void OnDisable()
    {
        SendRequestToBlender(RpcRequest.Disconnect);
        OnDisconnectFromBlender();
    }

    void SendRequestWithDataToBlender<T>(RpcRequest type, ref T payload) where T : struct
    {
        if (!TryCreateBlenderConnection())
        {
            Debug.LogError("Cannot send RPC message - connection cannot be established");
            return;
        }

        // 1 byte for the RpcMessageType followed by the struct.
        var buffer = new byte[1 + FastStructure.SizeOf<T>()];
        buffer[0] = (byte)type;
        FastStructure.CopyTo(ref payload, buffer, 1);
        
        Debug.Log($"Sending request {type} of size {buffer.Length}");

        RemoteRequest(buffer);
    }

    void SendRequestToBlender(RpcRequest type)
    {
        if (!TryCreateBlenderConnection())
        {
            Debug.LogError("Cannot send RPC message - connection cannot be established");
            return;
        }

        //var message = "Foo bar";
        //byte[] encoded = Encoding.UTF8.GetBytes(message);
        
        var buffer = new byte[1];
        buffer[0] = (byte)type;
        
        Debug.Log($"Sending request {type}");

        RemoteRequest(buffer);
    }

    void RemoteRequest(byte[] buffer)
    {
        Debug.Log($"Sending RPC of {buffer.Length} bytes");

        try
        {
            var result = rpc.RemoteRequest(buffer, 100);
            
            if (!result.Success)
            {
                Debug.Log("RPC was not a success");
                OnDisconnectFromBlender();
            }
            else
            {
                if (result.Data != null && result.Data.Length > 0)
                {
                    var responseType = (RpcResponse)result.Data[0];
                    
                    Debug.Log($"Got RPC success response {responseType}");

                    // Decode and delegate response types
                    switch (responseType)
                    {
                        case RpcResponse.BlenderState:
                            OnBlenderState(
                                FastStructure.FromBytes<BlenderViewport>(result.Data, 1)
                            );
                            break;
                        default:
                            Debug.LogWarning($"Unhandled RPC response {responseType}");
                            break;
                    }
                }
                else
                {
                    Debug.Log("0 length response data");
                }
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"Exception during RPC Request: {e.Message}");
            OnDisconnectFromBlender();
            throw;
        }
    }

    private void OnBlenderState(BlenderViewport blenderState)
    {
        /*Debug.Log($"Got blender state: {blenderState.version} with " +
            $"{blenderState.camera.width}x{blenderState.camera.height} camera"
        );*/
    }

    private void OnDisconnectFromBlender()
    {
        Debug.Log("Disconnecting RPC");

        rpc?.Dispose();
        rpc = null;
    }

    bool TryCreateBlenderConnection()
    {
        if (rpc != null)
        {
            return true;
        }

        try 
        {
            rpc = new RpcBuffer(BufferName, (msgId, payload) =>
            {
                Debug.Log($"Got payload {payload.Length}");
            });

            SendRequestWithDataToBlender(RpcRequest.Connect, ref unityState);
        }
        catch (Exception e)
        {
            Debug.LogError($"Failed to setup RPC Buffer: {e.Message}");
            throw;
        }

        return true;
    }

    // Update is called once per frame
    void Update()
    {
        //Sending messages to the pipe
        if (Input.GetKeyDown(KeyCode.Space))
        {
           SendRequestToBlender(RpcRequest.SyncBlenderState);
        }

        if (Input.GetKeyDown(KeyCode.E))
        {
            SendRequestWithDataToBlender(RpcRequest.SyncUnityState, ref unityState);
        }
    }
}
